"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var _bindInstanceProperty=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind")),React=_interopDefault(require("react")),_Object$create=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/object/create")),_Object$assign=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign")),_JSON$stringify=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/json/stringify")),_includesInstanceProperty=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes")),_filterInstanceProperty=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter")),_flatMapInstanceProperty=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/instance/flat-map")),_forEachInstanceProperty=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each")),_Object$keys=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys")),_reduceInstanceProperty=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/instance/reduce")),_Symbol=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/symbol")),_Array$isArray=_interopDefault(require("@babel/runtime-corejs3/core-js-stable/array/is-array")),memoize=_interopDefault(require("fast-memoize"));const isPlainObject=e=>e&&"object"==typeof e&&("function"!=typeof e.constructor||"Object"===e.constructor.name),merge=(e,t,r)=>{if(!isPlainObject(e))throw new Error("Target is not a plain object. Can't merge into a not 'plain object like' structure!");const a=_Array$isArray(t)?t:[t];let s=e;return _forEachInstanceProperty(a).call(a,t=>{if(!isPlainObject(t))return;const a=_Object$keys(t);_forEachInstanceProperty(a).call(a,a=>{const n=Object.hasOwnProperty.call(e,a),i=e[a],c=t[a],o=r?r(i,c,a):c;n&&o===i||(s===e&&(s=_Object$assign({},e)),s[a]=o)})}),s},mergeDeep=(e,t,r)=>merge(e,t,(e,t,a)=>isPlainObject(e)&&isPlainObject(t)?mergeDeep(e,t,r):r?r(e,t,a):t),parsePathname=e=>{if("string"!=typeof e)throw new Error(`Pathname is not valid. Expected: string! Received: ${Object.prototype.toString.call(e)}.`);const[t,...r]=e.split("/");if(t||!r.length)throw new Error("Pathname is not valid. It should start with '/'!");return r[0]||(r[0]="/"),r},addStrategyMerger=(e,t)=>_Array$isArray(e)&&_Array$isArray(t)?[...e,...t]:t,removeStrategyMerger=(e,t)=>_Array$isArray(e)&&_Array$isArray(t)?_filterInstanceProperty(e).call(e,(e,r)=>!_includesInstanceProperty(t).call(t,e)):t,mutateQueryParams=e=>memoize((t,r)=>mergeDeep(t,r,e)),addQueryParams=mutateQueryParams(addStrategyMerger),removeQueryParams=mutateQueryParams(removeStrategyMerger),update=(e,t,r)=>{if(!isPlainObject(e))throw new Error("Target is not a plain object. Can't update a not 'plain object like' structure!");if(!t||"string"!=typeof t)throw new Error(`Path is not valid. Expecting: string! Received: ${Object.prototype.toString.call(t)}.`);if(!r||"function"!=typeof r)throw new Error(`Updater is not valid. Expecting: function! Received: ${Object.prototype.toString.call(r)}.`);const a=Object.prototype.hasOwnProperty.call(e,t),s=e[t],n=r(s,t,{tail:!0});return a&&s===n?e:_Object$assign({},e,{[t]:n})},updateDeep=(e,t,r,a)=>{if(!isPlainObject(e))throw new Error("Target is not a plain object. Can't update a not 'plain object like' structure!");if(!t||!_Array$isArray(t))throw new Error(`Path is not valid. Expecting: array! Received: ${Object.prototype.toString.call(t)}.`);if(!r||"function"!=typeof r)throw new Error(`Updater is not valid. Expecting: function! Received: ${Object.prototype.toString.call(r)}.`);let s,n=a||(()=>({})),i=_Object$assign({},e),c=i;for(let a=0,i=t.length;a<i;a++)if(a===i-1){if(!s)return update(e,t[a],r);{const n=update(c,t[a],r);if(c===n)return e;s[t[a-1]]=n}}else{const e=r(c[t[a]]?c[t[a]]:n(t[a]),t[a],{tail:!1});c[t[a]]=_Object$assign({},e),s=c,c=c[t[a]]}return i},WILDCARD_SCOPE="*",QUERYSTRING_CACHE_STATE_KEY="@@__querystringCacheStateObject__@@",NESTED_KEY="nested",PERSISTED_KEY="persisted",SHADOW_KEY=_Symbol("shadow"),createKey=()=>Math.random().toString(36).substr(2,7),createPartialCache=e=>({nested:{},persisted:{},[SHADOW_KEY]:{},...e}),createStateObject=({mutations:e,...t}={})=>({[QUERYSTRING_CACHE_STATE_KEY]:{...t,key:createKey(),mutations:e||[]}}),pickBranchFromCache=(e,[t,...r],a=[])=>{if(t){const s=e["*"],n=e[t];return s&&s.mutated&&a.push(s),n&&n.mutated&&a.push(n),n?pickBranchFromCache(n.nested,r,a):a}return a},flushNestedPartialCaches=(e,t)=>_reduceInstanceProperty(t).call(t,(t,r)=>({...t,[r]:{...e[r],[SHADOW_KEY]:{},nested:flushNestedPartialCaches(e[r].nested,_Object$keys(e[r].nested))}}),{...e}),queryStore={get cache(){return this.history[this.currentHistoryKey]},set cache(e){this.history[this.currentHistoryKey]=e},add({pathname:e,state:t}){var r;const{key:a,mutations:s,foreign:n,respect:i}=t[QUERYSTRING_CACHE_STATE_KEY];if(Object.prototype.hasOwnProperty.call(this.history,a))return this.currentHistoryKey=a,this;let c=this.cache;return _forEachInstanceProperty(s).call(s,({scope:t,persist:r,add:a,remove:s})=>{var o;c=updateDeep(c,_flatMapInstanceProperty(o=parsePathname(t||e)).call(o,(e,t,{length:r})=>t<r-1?[e,"nested"]:e),(e,t,{tail:c})=>{if(c){const c=e||createPartialCache({path:t,mutated:!0});if(n)return{...c,persisted:i?c.persisted:{},[SHADOW_KEY]:i?a:{},nested:flushNestedPartialCaches(c.nested,_Object$keys(c.nested))};{const e=r?"persisted":SHADOW_KEY;let t=c[e];return s&&(t=removeQueryParams(t,s)),a&&(t=addQueryParams(t,a)),{...c,[e]:t,nested:flushNestedPartialCaches(c.nested,_Object$keys(c.nested))}}}return n&&!i&&"nested"!==t?createPartialCache({path:t,nested:e.nested}):e},e=>"nested"===e?{}:createPartialCache({path:e}))}),c=flushNestedPartialCaches(c,_filterInstanceProperty(r=_Object$keys(c)).call(r,t=>{var r;return!_includesInstanceProperty(r=["*",parsePathname(e)[0]]).call(r,t)})),this.currentHistoryKey=a,this.cache=c,this},resolveQueryString(e,t=[]){const r=pickBranchFromCache(this.cache,parsePathname(e));let a=_reduceInstanceProperty(r).call(r,(e,t)=>addQueryParams(e,{...t[SHADOW_KEY],...t.persisted}),{});return _forEachInstanceProperty(t).call(t,({add:e,remove:t})=>{t&&(a=removeQueryParams(a,t)),e&&(a=addQueryParams(a,e))}),this.stringifyQueryParams(a)},clear(){return this.history={},this.currentHistoryKey=createKey(),this.cache={},this},toString(){return _JSON$stringify(this.cache)}};let store;const createQueryStore=({initialCache:e,parseQueryString:t,stringifyQueryParams:r}={})=>{if(!store){const a=createKey();store=_Object$assign(_Object$create(_Object$assign(queryStore,{createStateObject:createStateObject,parseQueryString:t,stringifyQueryParams:r})),{currentHistoryKey:a,history:{[a]:e||{}}})}return store},QueryContext=React.createContext({}),resolvePath=(e,{pathname:t,mutations:r,hash:a,state:s={}})=>({pathname:t,search:e.resolveQueryString(t,r),hash:a,state:{...s,...e.createStateObject({mutations:r,...s[QUERYSTRING_CACHE_STATE_KEY]})}}),Query=({options:e,history:t,children:r,replace:a,respect:s})=>{a&&!s&&console.warn("There won't be much to replace if you are not respecting foreign query params. Consider using replace with respect!");const n=React.useMemo(()=>{const t=createQueryStore(e);return{queryStore:t,resolvePath:_bindInstanceProperty(resolvePath).call(resolvePath,null,t)}},[e]),[,i]=React.useState(null);return React.useEffect(()=>t.listen(({pathname:e,state:r,search:c})=>{let o=!1,u={...r};if(!u[QUERYSTRING_CACHE_STATE_KEY]){const e=n.queryStore.parseQueryString(c);u={...n.queryStore.createStateObject({respect:s,foreign:!0,mutations:[{add:e}]})},o=a||!1}u[QUERYSTRING_CACHE_STATE_KEY].replaced||n.queryStore.add({pathname:e,state:u}),o?t.replace(`${e}${n.queryStore.resolveQueryString(e)}`,{...u,[QUERYSTRING_CACHE_STATE_KEY]:{...u[QUERYSTRING_CACHE_STATE_KEY],replaced:!0}}):i(u)}),[n,t,a,s]),React.createElement(QueryContext.Provider,{value:{...n}},r)},QueryLink=({children:e,pathname:t,hash:r,state:a,mutations:s,...n})=>{const{resolvePath:i}=React.useContext(QueryContext);return e({...n,path:i({pathname:t,hash:r,mutations:s,state:a})})};exports.NESTED_KEY="nested",exports.PERSISTED_KEY="persisted",exports.QUERYSTRING_CACHE_STATE_KEY=QUERYSTRING_CACHE_STATE_KEY,exports.Query=Query,exports.QueryContext=QueryContext,exports.QueryLink=QueryLink,exports.SHADOW_KEY=SHADOW_KEY,exports.addQueryParams=addQueryParams,exports.createQueryStore=createQueryStore,exports.removeQueryParams=removeQueryParams;
